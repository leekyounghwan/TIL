## **플러터가 등장한 이유**

**[문제점]**

- ios와 android 이중 개발 문제
- 크로스플랫폼 프레임워크의 성능 한계 문제
- 자바스크립트 브릿지 사용시 CPU와 메모리 사용량 증가로 인한 성능 저하 문제

`위 문제점들을 해결하기 위해 등장`

**[특징]**

- Skia 그래픽 라이브러리
- C/C++ 엔진 사용
- 다트 코드를 C/C++ 엔진으로 직접 컴파일
- 자바스크립트 브릿지 불필요

`하나의 언어로 모든 플랫폼에 동일한 UI/UX를 고성능으로 표현하기 위해 등장`

## **플러터의 장점**

1. 크로스 플랫폼 개발 도구
    
    `단일 코드베이스로 모든 플랫폼 개발 가능`
    
2. 핫 리로드와 빠른 컴파일
    
    `컴파일 평균 1분, 핫 리로드 1초 미만`
    
3. 구글의 적극적인 지원
4. 네이티브 앱에 필적하는 퍼포먼스
    
    `Skia엔진 사용으로 지연없이 네이티브 수준으로 컴파일`
    
5. 일괄된 디자인 / 플랫폼별 UI 처리
    
    `플랫폼 특성에 맞는 머티리얼 디자인 제공`
    
6. 완성도 높은 위젯
7. 뛰어난 디버깅

## **플러터는 어떤 언어로 개발 되는가?**

Dart 언어

## **플러터의 주요 특징**

- Skia 그래픽 라이브러리
- C/C++ 엔진 사용
- 다트 코드를 C/C++ 엔진으로 직접 컴파일
- 자바스크립트 브릿지 불필요

## 핫 리로드

`앱을 다시 시작하지 않고도 코드 변경 사항을 즉시 반영하여 UI를 업데이트 할 수 있는 기능`

코드를 수정하면 변경된 부분만 다시 컴파일하고 실행중인 앱에 적용

[주요 특징]

- 빠른 피드백
- 상태유지
- UI 개발 최적화

## Flutter SDK 설치 시 PATH 설정이 필요한 이유

- flutter, dart 같은 명령어를 전역에서 실행 가능하게 하기 위해
- PATH에 Flutter SDK의 bin 디렉토리를 추가해야 Flutter 개발 도구들이 정상 작동
- IDE 도 Flutter SDK 자동 인식하려면 PATH 설정이 되어있어야 함

## VS Code에서 플러터 개발에 가장 필수적인 확장

Flutter

## flutter doctor 명령어의 역할

- 개발환경 점검 `개발 도구, IDE 플러그인 등이 설치됐는지 확인`
- 설정 상태 표시 `구성 요소 설치 여부, 버전, 상태 출력`
- 문제 진단 `누락 항목, 오류 시 메시지`
- 해결 가이드 제공

## IDE 단축키 설정 이유

개발 생산성과 효율성을 극대화하기 위해

- 작업 속도 향상
- 반복 작업 최소화
- UI 탐색 시간 절약
- 개인화된 개발 환경 구성

## Flutter 프로젝트에서 필요한 패키지를 추가할 때 사용하는 파일

pubspec.yaml

## final 과 const의 차이

final은 한 번만 할당 가능한 런타임 상수

const는 컴파일 시점에 값이 결정되는 완전한 상수

## Dart의 기본 자료형

int, double, String, bool, List, Set, Map, Null

## late 키워드의 역할

변수를 선언 할 때 즉시 값을 할당하지 않고, 나중에 값을 할당

- 지연 초기화
- null safety와 함께 사용
- 초기화하지 않으면 런타임 오류 발생

## ? 연산자

- Nullable 타입
- null을 가질 수 없는 타입에 ?을 붙이면 허용함

## 변수를 한 번만 할당하고 변경할 수 없게 만드는 키워드

final

## 함수 선언

```dart
반환타입 함수이름(매개변수) {
	실행 코드;
}
```

## var 선언

초기 값을 보고 변수의 타입을 자동으로 결정

`var name = “Lee”;`

`name = “Kim”; 가능`

`name = 123; 불가능(앞에서 “Lee”라고 초기값을 설정해 name은 문자열임)`

`var x; 불가능(초기값 업음)`

`var y = null; 불가능(null X)`

## 반복문

for문, forEach문, for-in문, while문, do-while문

## OOP(개체지향프로그래밍)의 핵심 개념

- 캡슐화 - 데이터와 기능을 묶고 은닉
- 상속 - 기존 클래스 기능 확장
- 다형성 - 같은 메서드 다른 동작
- 추상화 - 필요한 인터페이스만 제공

## 플러터 앱의 가장 기본 단위

위젯(Widget)

## StatelessWidget의 특징

- 상태 없음 - 내부 상태를 가지지 않으며, UI가 고정되어 있음
- 불변성 - 생성 이후에는 위젯의 속성이나 UI가 변경되지 않음
- 간단한 구조 - build() 메서드만 구현하면 되며, 상태 관리 코드 필요 X
- 재사용 가능 - 동일한 UI를 여러곳에서 쉽게 재사용 가능
- 성능 효율적 - 상태 변화에 따른 리렌더링이 없기 때문에 성능에 유리함

## StatefulWidget에서 상태를 관리하는 클래스

State

## 위젯 트리의 루트에 위치한 것

- MaterialApp
- CupertinoApp
- WidgetApp

## Column, Row  위젯 방향

- Column : 세로
- Row : 가로

## Animated Container 의 기능

위젯의 속성 변화에 따라 자동으로 애니메이션을 적용해주는 위젯

- 속성 변화 애니메이션 -  다양한 속성의 변경을 자동으로 애니메이션 처리
- 자동 트렌지션 - 상태가 변경되면 이전 값과 새로운 값 사이를 지정된 durationrhk curve에 따라 부드럽게 전환
- 간단한 구현

## Navigator.push()의 역할

새로운 화면을 현재 화면 위에 쌓아 올리는 역할

[핵심 기능]

- 새 화면으로 이동
- 스택 구조 기반
- 뒤로가기 기능

push() - 새 화면 위에 스택 추가

pop() - 현재 화면 제거

## setState() 호출의 목적

StatefulWidget의 상태를 변경하고, 그에 따라 UI를 다시 빌드하도록 트리거하는 것

- 상태 변경 알림 - 내부 데이터가 변경되었음을 Flutter 프레임 워크에 알림
- UI 업데이트 - 변경된 상태를 반영하여 build() 메서드 다시 실행
- 최소 범위 리렌더링 - 해당 위젯만 다시 빌드되므로 성능에 효율적
